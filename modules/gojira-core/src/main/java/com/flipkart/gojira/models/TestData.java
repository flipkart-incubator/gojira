/*
 * Copyright 2020 Flipkart Internet, pvt ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.flipkart.gojira.models;

import com.flipkart.gojira.core.Mode;
import java.lang.reflect.Method;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentSkipListMap;

/**
 * Data structure that represents data being recorded during {@link Mode#PROFILE} mode and used in
 * other modes during execution.
 */
public class TestData<
    InputDataT extends TestRequestData<T>,
    OutputDataT extends TestResponseData<T>,
    T extends TestDataType> {

  /**
   * ID field which is what is expected to be used to store data in data store. It is generated by
   * default using a combination of {@link System#nanoTime()} and {@link Thread#getId()}. It can be
   * overridden by the client application.
   */
  private String id = String.valueOf(System.nanoTime()) + Thread.currentThread().getId();

  /**
   * This field stores recorded data per method. It uses a {@link ConcurrentHashMap} to store data
   * against different methods. Key is {@link Method#toGenericString()}. Value is a {@link
   * ConcurrentSkipListMap} of method data. The data structure used allows for data to be stored for
   * multiple methods and multiple times for a single method in a thread safe manner. The Key for
   * {@link ConcurrentSkipListMap} is a {@link Long} variable which is expected to be increasing as
   * new entries are added. It is suggested to be kept this way because in most cases, entries would
   * be removed in the same order as they are added. The value is a {@link ConcurrentHashMap} of
   * method data. //TODO: Check if {@link java.util.HashMap} should be enough instead of {@link
   * ConcurrentHashMap}.
   */
  private ConcurrentHashMap<
          String, ConcurrentSkipListMap<Long, ConcurrentHashMap<MethodDataType, List<MethodData>>>>
      methodDataMap = new ConcurrentHashMap<>();

  /**
   * Request data which is captured for initiating execution in different {@link Mode}.
   */
  private InputDataT requestData;

  /**
   * Request data which is captured for comparing during execution in different {@link Mode}.
   */
  private OutputDataT responseData;


  public String getId() {
    return id;
  }

  public void setId(String id) {
    this.id = id;
  }

  public ConcurrentHashMap<
          String, ConcurrentSkipListMap<Long, ConcurrentHashMap<MethodDataType, List<MethodData>>>>
      getMethodDataMap() {
    return methodDataMap;
  }

  public void setMethodDataMap(
      ConcurrentHashMap<
              String,
              ConcurrentSkipListMap<Long, ConcurrentHashMap<MethodDataType, List<MethodData>>>>
          methodDataMap) {
    this.methodDataMap = methodDataMap;
  }

  public InputDataT getRequestData() {
    return requestData;
  }

  public void setRequestData(InputDataT requestData) {
    this.requestData = requestData;
  }

  public OutputDataT getResponseData() {
    return responseData;
  }

  public void setResponseData(OutputDataT responseData) {
    this.responseData = responseData;
  }
}
